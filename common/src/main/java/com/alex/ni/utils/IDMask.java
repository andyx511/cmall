package com.alex.ni.utils;

public class IDMask {

	// Note: it is a private base64 encoding map
	// in which the lower case characters are settled before upper case characters
	private static final String base64EncodingMap = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
	public static final String key = "1234567890abcdef1234567890abcdef";

	public static String encodeBase64(String s) {
		char src[] = s.toCharArray();
		int l = src.length;
		char dst[] = new char[l * 4 / 3 + 4];
		int pos = 0;
		int sp = 0;
		int dp = 0;

		while (l > 2) {
			sp = pos * 3;
			dp = pos * 4;

			char c = src[sp];
			c = (char) ((c >> 2) & 0x3F);
			dst[dp] = base64EncodingMap.charAt(c);
			dp ++;
			c = (char) (((src[sp] << 4) & 0x30) | ((src[sp + 1] >> 4) & 0x0F));
			dst[dp] = base64EncodingMap.charAt(c);
			dp ++;
			sp ++;
			c = (char) (((src[sp] << 2) &0x3c) | ((src[sp + 1] >> 6) &0x03));
			dst[dp] = base64EncodingMap.charAt(c);
			dp ++;
			sp ++;
			c = (char) (src[sp] & 0x3F);
			dst[dp] = base64EncodingMap.charAt(c);
			dp ++;
			l -= 3;
			pos ++;
		}
		if (l == 2) {
			sp = pos * 3;
			dp = pos * 4;

			char c = src[sp];
			c = (char) ((c >> 2) & 0x3F);
			dst[dp] = base64EncodingMap.charAt(c);
			dp ++;
			c = (char) (((src[sp] << 4) & 0x30) | ((src[sp + 1] >> 4) & 0x0F));
			dst[dp] = base64EncodingMap.charAt(c);
			dp ++;
			sp ++;
			c = (char) ((src[sp] << 2) &0x3c);
			dst[dp] = base64EncodingMap.charAt(c);
			dp ++;
		}
		else if (l == 1) {
			sp = pos * 3;
			dp = pos * 4;

			char c = src[sp];
			c = (char) ((c >> 2) & 0x3F);
			dst[dp] = base64EncodingMap.charAt(c);
			dp ++;
			c = (char) ((src[sp] << 4) & 0x30);
			dst[dp] = base64EncodingMap.charAt(c);
			dp ++;
		}
		String d = new String(dst, 0 ,dp);
		return d;
	}

	private static final char[] base64DecodeMap = {
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,		// 0x
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,		// 1x
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 63,   0xFF, 0xFF,		// 2x
		0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,		// 3x
		0xFF, 35,   37,   38,   39,   40,   41,   42,   43,   44,   45,   46,   47,   48,   49,   50,		// 4x
		51,   52,   53,   54,   55,   56,   57,   58,   59,   60,   61,   0xFF, 0xFF, 0xFF, 0xFF, 62,		// 5x
		0xFF, 10,   11,   12,   13,   14,   15,   16,   17,   18,   19,   20,   21,   22,   23,   24,		// 6x
		25,   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,   0xFF, 0xFF, 0xFF, 0xFF, 0xFF,		// 7x
	};

	public static String decodeBase64(String s) {
		char src[] = s.toCharArray();
		int l = src.length;
		char dst[] = new char[l * 3 / 4 + 3];
		int pos = 0;
		int sp = 0;
		int dp = 0;

		while (l > 3) {
			sp = pos * 4;
			dp = pos * 3;

			char c = src[sp];
			if (c > 0x7F)
				break;
			c = base64DecodeMap[c];
			sp ++;
			char ch = c;
			ch <<= 2;
			ch &= 0xFC;
			c = src[sp];
			if (c > 0x7F)
				break;
			c = base64DecodeMap[c];
			sp ++;
			ch |= (char) ((c >> 4) & 0x03);
			dst[dp] = ch;
			dp ++;
			ch = c;
			ch <<= 4;
			ch &= 0xF0;
			c = src[sp];
			if (c > 0x7F)
				break;
			c = base64DecodeMap[c];
			sp ++;
			ch |= (char) ((c >> 2) & 0x0F);
			dst[dp] = ch;
			dp ++;
			ch = c;
			ch <<= 6;
			ch &= 0xC0;
			c = src[sp];
			if (c > 0x7F)
				break;
			c = base64DecodeMap[c];
			sp ++;
			ch |= (char) (c & 0x3F);
			dst[dp] = ch;
			dp ++;
			pos ++;
			l -= 4;
		}
		if (l == 3) {
			sp = pos * 4;
			dp = pos * 3;

			char c = src[sp];
			if (c > 0x7F)
				c &= 0x7F;
			c = base64DecodeMap[c];
			sp ++;
			char ch = c;
			ch <<= 2;
			ch &= 0xFC;
			c = src[sp];
			if (c > 0x7F)
				c &= 0x7F;
			c = base64DecodeMap[c];
			sp ++;
			ch |= (char) ((c >> 4) & 0x03);
			dst[dp] = ch;
			dp ++;
			ch = c;
			ch <<= 4;
			ch &= 0xF0;
			c = src[sp];
			if (c > 0x7F)
				c &= 0x7F;
			c = base64DecodeMap[c];
			sp ++;
			ch |= (char) ((c >> 2) & 0x0F);
			dst[dp] = ch;
			dp ++;
			ch = c;
			ch <<= 6;
			ch &= 0xC0;
			dst[dp] = ch;
			dp ++;
		}
		else if (l == 2) {
			sp = pos * 4;
			dp = pos * 3;

			char c = src[sp];
			if (c > 0x7F)
				c &= 0x7F;
			c = base64DecodeMap[c];
			sp ++;
			char ch = c;
			ch <<= 2;
			ch &= 0xFC;
			c = src[sp];
			if (c > 0x7F)
				c &= 0x7F;
			c = base64DecodeMap[c];
			sp ++;
			ch |= (char) ((c >> 4) & 0x03);
			dst[dp] = ch;
			dp ++;
			ch = c;
			ch <<= 4;
			ch &= 0xF0;
			dst[dp] = ch;
			dp ++;
		}
		else if (l == 1) {
			// could not be l == 1 if the string is generated by encodeBase64()
			// but it is possible when we think a string is a base64 string
			sp = pos * 4;
			dp = pos * 3;

			char c = src[sp];
			if (c > 0x7F)
				c &= 0x7F;
			c = base64DecodeMap[c];
			sp ++;
			char ch = c;
			ch <<= 2;
			ch &= 0xFC;
			dst[dp] = ch;
			dp ++;
		}
		String d = new String(dst, 0, dp);
		return d;
	}

	private static char hex2Char(char c) {
		if ((c >= '0') && (c <= '9')) {
			c -= '0';
		}
		else if ((c >= 'A') && (c <= 'Z')) {
			c -= 'A';
			c += '\12';
		}
		else if ((c >= 'a') && (c <= 'z')) {
			c -= 'a';
			c += '\12';
		}
		else {
			c = '\0';
		}
		return c;
	}

	private static String hex2Str(String s) {
		char[] src = s.toCharArray();
		int l = src.length;
		l >>= 1;
		char[] dst = new char[l];

		for (int i=0; i<l; i++) {
			char c = src[i * 2];
			c = hex2Char(c);
			dst[i] = (char) ((c << 4) & 0xF0);
			c = src[i * 2 + 1];
			c = hex2Char(c);
			dst[i] |= (char) (c & 0x0F);
		}
		String d = new String(dst);
		return d;
	}

	private static char char2Hex(char c) {
		if (c < 10)
			c += '0';
		else {
			c -= 10;
			c += 'a';
		}
		return c;
	}

	private static String str2Hex(String s) {
		char[] src = s.toCharArray();
		int l = src.length;
		char[] dst = new char[l * 2];

		for (int i=0; i<l; i++) {
			char c = src[i];
			char ch = (char) ((c >> 4) & 0x0F);
			ch = char2Hex(ch);
			dst[i * 2] = ch;
			ch = (char) (c & 0x0F);
			ch = char2Hex(ch);
			dst[i * 2 + 1] = ch;
		}
		String d = new String(dst);
		return d;
	}

	private static String xor(String s1, String s2) {
		char[] o1 = s1.toCharArray();
		char[] o2 = s2.toCharArray();
		int l = (o1.length < o2.length) ? o1.length : o2.length;
		char[] r = new char[l];

		for (int i=0; i<l; i++) {
			r[i] = (char) (o1[i] ^ o2[i]);
		}
		return new String(r);
	}

	public static String encode(String id, String key) {
		String ds = decodeBase64(id);
//		System.out.println("ds: " + str2Hex(ds));
		String ks = hex2Str(key);
//		System.out.println("key: " + str2Hex(ks));
		String r = xor(ds, ks);
		return str2Hex(r);
	}

	public static String decode(String id, String key) {
		String ds = hex2Str(id);
		String ks = hex2Str(key);
		String r = xor(ds, ks);
//		System.out.println("result: " + str2Hex(r));
		String rs = encodeBase64(r);
		return rs;
	}
}
